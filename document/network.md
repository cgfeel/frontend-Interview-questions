# 整理网络相关的面试题

### 🔴 `http/2` 相对于 `http/1.1` 更新了什么？

来自：`Gate.io`

<details>

<summary>HTTP/2 相对于 HTTP/1.1 有以下主要更新：</summary>

**一、二进制分帧层**

在 `HTTP/2` 中，引入了二进制分帧层。`HTTP/1.1` 的报文是基于文本的，而 `HTTP/2` 将报文分割为更小的帧，并且以二进制格式传输。这带来了几个好处：

1. 更高效的解析：二进制格式的帧可以更快速地被解析，减少了处理时间。
2. 多路复用：允许在同一个连接上同时发送多个请求和响应，而无需按照顺序依次进行。每个请求和响应都被分割成不同的帧，它们可以交错传输，极大地提高了传输效率。

**二、多路复用**

`HTTP/1.1` 中，如果客户端同时发起多个请求，这些请求需要依次排队等待响应，即使它们所请求的资源可以并行获取。而在 `HTTP/2` 中：

1. 并行传输：多个请求和响应可以在同一个连接上同时进行传输，无需等待。这大大减少了页面加载时间，特别是对于包含大量资源的页面。
2. 消除队头阻塞：在 `HTTP/1.1` 中，如果一个请求出现问题，会阻塞后续请求的处理。而 `HTTP/2` 的多路复用机制消除了这种队头阻塞问题，一个请求的问题不会影响其他请求的传输。

**三、头部压缩**

`HTTP/2` 使用 `HPACK` 压缩算法对头部信息进行压缩：

1. 减少传输开销：`HTTP` 请求和响应的头部通常包含大量重复的信息，如 `Cookie`、`User-Agent` 等。通过压缩头部，可以显著减少传输的数据量，提高传输效率。
2. 动态表更新：`HPACK` 算法维护了一个动态表，用于存储已经出现过的头部字段和值。对于重复出现的头部信息，可以使用更短的编码进行传输。

**四、服务器推送**

`HTTP/2` 允许服务器主动向客户端推送资源：

1. 提前加载：服务器可以根据客户端的请求，预测客户端可能需要的其他资源，并主动将这些资源推送给客户端。这样，当客户端真正需要这些资源时，可以直接从缓存中获取，减少了请求的延迟。
2. 优化用户体验：对于一些首次访问的页面，服务器推送可以提前加载关键资源，提高页面的加载速度，提升用户体验。

> 但是 `chrome` 关闭了 `HTTP/2` 的服务推送：https://developer.chrome.com/blog/removing-push?hl=zh-cn

</details>

### 🔴 请聊一下 `http3`？

来自：`Gate.io`

<details>

<summary>HTTP/3 是 HTTP 协议的一个重要演进版本，具有多方面的改进和特点，以下是对 HTTP/3 的详细介绍：</summary>

#### 1. 基础协议的变化：

**从 `TCP` 到 `UDPs`**

`HTTP/1.1` 和 `HTTP/2` 都是基于 `TCP` 协议的，而 `HTTP/3` 则基于 `UDP` 协议。`TCP` 是一种面向连接、可靠的传输协议，但在一些情况下，如网络拥塞时，可能会出现队头阻塞等问题，影响传输效率。`UDP` 是一种无连接的协议，本身不可靠，但 `HTTP/3` 在 `UDP` 的基础上进行了改进和增强，使其能够提供可靠的传输服务。

> `HTTP/1.1` 和 `HTTP/2` 都是基于 `TCP` 协议，而 `HTTP/3` 选择 `UDP` 协议主要是为了解决 `TCP` 协议存在的一些问题。虽然 `TCP` 是一种可靠的、面向连接的传输协议，但在某些情况下，比如网络拥塞时，`TCP` 的性能表现可能不尽如人意，会出现连接建立时间长、队头阻塞等问题。而 `UDP` 是一种无连接的、不可靠的传输协议，本身不具备 `TCP` 的复杂拥塞控制和连接管理机制，但正因为如此，它在一些方面具有优势，比如更低的延迟和更高的传输效率。
>
> 为了在 `UDP` 协议的基础上实现可靠的数据传输，`HTTP/3` 采用了 `QUIC`（Quick UDP Internet Connections）协议。`QUIC` 协议在 `UDP` 之上实现了类似 `TCP` 的可靠性、拥塞控制、流量控制等功能，同时还具有一些额外的优势，如减少连接建立时间、支持连接迁移等。所以，`HTTP/3` 实际上是基于 `QUIC` 协议的，而 `QUIC` 协议是基于 `UDP` 协议的，这使得 `HTTP/3` 能够在保持高效传输的同时，提供可靠的数据传输服务。

#### 2. 主要优势：

**多路复用改进：**

在 `HTTP/2` 中已经实现了多路复用，可以在一个连接上同时发送多个请求和响应，提高了传输效率。但 `HTTP/2` 的多路复用是基于 `TCP` 有序字节流的，在丢包的情况下仍然可能会出现队头阻塞问题，导致后续的请求和响应被阻塞。`HTTP/3` 基于 `UDP` 实现了真正的多路复用，每个请求和响应都被分割 c 提高了传输效率和并发能力。

**更快的连接建立：**

在 `HTTP/1.1` 和 `HTTP/2` 中，建立连接需要进行 `TCP` 三次握手和 `TLS` 握手，这两个过程会消耗一定的时间，增加了连接的延迟。`HTTP/3` 集成了 `TLS` 加密层，并且通过改进的握手机制，只需要 1 个 `RTT`（Round-Trip Time，往返时间）就可以完成连接建立和密钥协商，大大减少了连接建立的时间。

**连接迁移支持：**

在移动互联网环境下，设备的网络连接可能会频繁切换，例如从 `Wi-Fi` 切换到移动网络，或者在不同的基站之间切换。对于基于 `TCP` 的 `HTTP/1.1` 和 `HTTP/2` 来说，网络连接的切换可能会导致连接中断，需要重新建立连接。`HTTP/3` 的 `QUIC` 层实现了连接迁移功能，能够在网络连接发生变化时，保持连接的连续性，减少了连接中断和重新建立连接的开销。

**头部压缩优化：**

在移动互联网环境下，设备的网络连接可能会频繁切换，例如从 `Wi-Fi` 切换到移动网络，或者在不同的基站之间切换。对于基于 `TCP` 的 `HTTP/1.1` 和 `HTTP/2` 来说，网络连接的切换可能会导致连接中断，需要重新建立连接。`HTTP/3` 的 `QUIC` 层实现了连接迁移功能，能够在网络连接发生变化时，保持连接的连续性，减少了连接中断和重新建立连接的开销。

#### 3. 应用场景：

**对实时性要求高的应用：**

例如在线游戏、实时视频会议等，这些应用对网络延迟和传输效率要求非常高，`HTTP/3` 的低延迟和高效传输特性能够为用户提供更好的体验。

**移动互联网应用：**

在移动网络环境下，网络连接的稳定性和带宽都可能受到限制，`HTTP/3` 的连接迁移功能和高效传输能力可以更好地适应移动网络的特点，为移动应用提供更稳定、快速的网络服务。

**大规模分布式系统：**

在大规模的分布式系统中，节点之间的通信频繁，对网络性能的要求很高。`HTTP/3` 的多路复用和高效传输特性可以提高系统的通信效率，降低系统的延迟和带宽消耗。

不过，`HTTP/3` 也面临一些挑战和问题，例如需要服务器和客户端的支持才能发挥其优势，在推广和普及过程中可能会遇到一些困难。但总体来说，`HTTP/3` 是未来网络通信的一个重要发展方向，具有广阔的应用前景。

</details>

### 🔴 `HTTP/3` 这么好为什么用的人不多？

来自：`题目衍伸`

<details>

<summary>尽管 HTTP/3 有诸多优势，但使用的人不多，主要有以下原因：</summary>

**1. 浏览器支持有限：**

- 在 `HTTP/3` 推出的初期，很多浏览器对其支持不完善或默认情况下是禁用的。虽然一些主流浏览器如 `Chrome`、`Firefox` 等已经支持 `HTTP/3`，但需要用户手动开启相关功能或者在特定的版本中才支持。这对于普通用户来说，使用 `HTTP/3` 需要额外的操作和了解，增加了使用的门槛，导致很多用户仍然使用默认的 `HTTP/1.1` 或 `HTTP/2`。
- 部分老旧版本的浏览器可能根本不支持 `HTTP/3`，而一些企业或机构由于各种原因无法及时更新浏览器，这也限制了 `HTTP/3` 的普及。

**2. 网络基础设施兼容性问题：**

- 中间设备和网络代理：网络中存在大量的中间设备，如防火墙、负载均衡器、反向代理等，这些设备在设计时主要是针对 `HTTP/1.1` 和 `HTTP/2` 基于 `TCP` 的协议。对于基于 `UDP` 的 `HTTP/3`，这些中间设备可能无法正确识别、处理或转发 `HTTP/3` 的数据包，导致数据传输出现问题。为了使这些设备支持 `HTTP/3`，需要对其进行升级或配置调整，这需要大量的时间和成本。
- 网络运营商：网络运营商的网络架构和设备也可能对 `HTTP/3` 的支持有限。一些网络运营商可能需要对其网络基础设施进行升级改造，才能更好地支持 `HTTP/3` 的传输，这需要投入大量的资金和资源，因此他们在推广和支持 `HTTP/3` 方面可能会比较谨慎。

**3. 服务器端配置和升级成本：**

- 服务器软件升级：要支持 `HTTP/3`，服务器需要安装相应的软件和库，并且进行配置和优化。对于一些老旧的服务器系统，可能需要进行较大的升级改造才能支持 `HTTP/3`，这会带来额外的成本和工作量。对于一些小型网站或资源有限的服务器管理员来说，可能会因为成本和技术难度而选择继续使用 `HTTP/1.1` 或 `HTTP/2`。
- 资源消耗和性能优化：`HTTP/3` 的实现需要消耗一定的服务器资源，例如 `CPU`、内存等。在高并发的情况下，服务器需要具备足够的性能来处理 `HTTP/3` 的请求，这可能需要对服务器进行硬件升级或优化，增加了服务器的运营成本。

**4. 网站开发者的认知和接受程度：**

- 学习成本：网站开发者需要学习和了解 `HTTP/3` 的新特性、协议规范和开发方法，这需要花费一定的时间和精力。对于已经熟悉 `HTTP/1.1` 和 `HTTP/2` 的开发者来说，切换到 `HTTP/3` 可能需要重新调整他们的开发思维和代码实现，存在一定的学习曲线。
- 兼容性问题：在将网站从 `HTTP/1.1` 或 `HTTP/2` 升级到 `HTTP/3` 的过程中，可能会出现一些兼容性问题，例如与现有插件、库或第三方服务的不兼容。开发者需要花费时间来解决这些兼容性问题，确保网站的正常运行，这也增加了开发者对 `HTTP/3` 的顾虑。

**5. 缺乏大规模应用案例和实践经验：**

- 由于 `HTTP/3` 相对较新，目前还没有足够多的大规模应用案例和实践经验可供参考。很多网站管理员和开发者对 `HTTP/3` 的性能、稳定性和安全性存在疑虑，担心在实际应用中会出现问题。相比之下，`HTTP/1.1` 和 `HTTP/2` 已经经过了长时间的实践检验，开发者和管理员对其性能和问题有更深入的了解，更愿意选择相对成熟的协议。

</details>

### 🔴 `URL` 输入地址发生什么？

来自：`异联信息`

<details>

<summary>当你在浏览器的 URL 栏输入一个地址后，从前端角度会发生以下一系列过程：</summary>

#### 一、用户输入阶段

当你开始在 `URL` 栏输入地址时，浏览器可能会根据你的输入进行自动补全，这通常是基于你的浏览历史和书签等信息。同时，浏览器的地址栏会实时显示你正在输入的地址，并进行语法检查和格式校验，确保输入的地址符合 `URL` 的规范。

#### 二、请求发起阶段

**1. 解析 `URL`：**

- 浏览器会对输入的 `URL` 进行解析，识别出协议（如 `HTTP`、`HTTPS` 等）、主机名（域名或 `IP` 地址）、端口号（如果有指定）、路径和查询参数等信息。
- 例如，对于 `URL` 为 `https://www.example.com/page?param1=value1&param2=value2`，浏览器会识别出协议为 `https`，主机名为 `www.example.com`，路径为 `/page`，查询参数为 `param1=value1&param2=value2`。

**2. `DNS` 解析：**

- 如果输入的是域名，浏览器会启动 `DNS`（Domain Name System）解析过程，将域名转换为对应的 `IP` 地址。这通常涉及向 `DNS` 服务器发送查询请求，以获取目标服务器的 `IP` 地址。
- 例如，当浏览器解析 `www.example.com` 时，会向 `DNS` 服务器发送查询请求，`DNS` 服务器会返回该域名对应的 `IP` 地址，如 `192.168.1.1`。

**3. 建立连接：**

- 根据解析出的协议和 `IP` 地址，浏览器会尝试与目标服务器建立连接。如果是 `HTTP` 或 `HTTPS` 协议，通常会使用 `TCP` 协议进行连接建立。
- 在建立连接的过程中，浏览器会进行三次握手，与服务器建立可靠的连接通道。

**4. 发送请求：**

- 一旦连接建立成功，浏览器会根据解析出的路径和查询参数等信息，构建 `HTTP` 请求报文，并将其发送给服务器。
- `HTTP` 请求报文通常包括请求方法（如 `GET`、`POST` 等）、请求头（包含各种元信息，如用户代理、接受的内容类型等）和请求体（如果有）。

例如，对于一个 `GET` 请求，请求报文可能如下：

```
GET /page?param1=value1&param2=value2 HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36
```

#### 三、服务器响应阶段

**1. 接收请求：**

- 服务器接收到浏览器发送的 `HTTP` 请求报文后，会对请求进行解析，提取出请求方法、路径、查询参数等信息。
- 服务器根据这些信息确定如何处理请求，并准备相应的响应内容。

**2. 处理请求：**

- 服务器根据请求的路径和方法，调用相应的后端逻辑进行处理。这可能涉及访问数据库、执行计算、调用其他服务等操作。
- 例如，如果请求的是一个动态网页，服务器可能会执行相应的脚本语言（如 `PHP`、`Python`、`Node.js` 等）来生成页面内容。

**3. 构建响应：**

服务器处理完请求后，会构建 `HTTP` 响应报文。响应报文通常包括响应状态码（如 `200` OK、`404` Not Found 等）、响应头（包含各种元信息，如内容类型、内容长度等）和响应体（即实际的页面内容）。

例如，对于一个成功的响应，响应报文可能如下：

```
HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8
Content-Length: 1234
```

> 响应体中可能包含 `HTML`、`CSS`、`JavaScript` 等前端资源，以及图片、视频等多媒体内容。

**4. 发送响应：**

服务器将构建好的 `HTTP` 响应报文发送回浏览器。

#### 四、浏览器接收响应阶段

**1. 接收响应：**

- 浏览器接收到服务器发送的 `HTTP` 响应报文后，会对响应进行解析，提取出状态码、响应头和响应体等信息。
- 浏览器根据状态码判断请求是否成功，如果状态码为 `200` OK 表示请求成功，其他状态码可能表示请求失败或出现错误。

**2. 处理响应：**

- 如果响应的内容类型是 `HTML`，浏览器会开始解析 `HTML` 文档，构建文档对象模型（`DOM`）树。在解析 `HTML` 的过程中，浏览器会遇到 `CSS` 和 `JavaScript` 等资源的引用，会并行地发起请求获取这些资源。
- `CSS` 资源会被解析并应用到 `DOM` 树上，以确定页面的样式。`JavaScript` 资源会被下载并执行，可能会对 `DOM` 树进行动态修改、发起新的请求等操作。

**3. 渲染页面：**

- 浏览器根据构建好的 `DOM` 树和应用里 `CSS` 样式的结果，进行页面的渲染。这包括确定页面的布局、绘制页面元素、显示图片等多媒体内容。
- 渲染过程是一个逐步进行的过程，浏览器会尽可能快地显示部分内容，同时继续加载和处理其他资源，以提供更好的用户体验。

**4. 交互与更新：**

一旦页面渲染完成，用户可以与页面进行交互，如点击链接、填写表单、滚动页面等。这些交互会触发新的请求或 `JavaScript` 事件处理程序的执行，从而导致页面的更新和重新渲染。

#### 总结

总之，当你在浏览器的 `URL` 栏输入一个地址后，前端会经历一系列复杂的过程，包括 `URL` 解析、`DNS` 解析、建立连接、发送请求、接收响应、处理响应和渲染页面等，最终向用户展示目标页面的内容。这些过程涉及到多个技术层面，包括网络通信、协议解析、前端开发等，共同协作以实现快速、准确地加载和显示网页内容。

</details>

### 🔴 说一下浏览器的 `CORS` 同源策略？

来自：`Gate.io`、`渡一`

> `Gate.io` 中的原问题是：浏览器中的 `options` 请求说一下？

<details>

<summary>答案：</summary>

#### `CORS` 同源策略

浏览器的同源策略：

- 浏览器出于安全考虑，对同源请求放行，对异源请求限制（即跨域），这些限制规则统称为同源策略。
- 这些限制造成的开发问题，称之为跨域（异源）问题

什么是同源请求：

- 当一个请求 `url` 的协议、域名、端口三者之间任意一个与当前页面 `url` 不同即为跨域

| 当前页面 `url`          | 被请求页面 `url`                  | 是否跨域 | 原因                           |
| ----------------------- | --------------------------------- | -------- | ------------------------------ |
| `https://www.test.com/` | `https://www.test.com/index.html` | 否       | 同源（协议、域名、端口号相同） |
| `https://www.test.com/` | `http://www.test.com/index.html`  | 跨域     | 协议不同（`https`/`http`）     |
| `https://www.test.com/` | `https://www.baidu.com/`          | 跨域     | 主域名不同（`test`/`baidu`）   |
| `https://www.test.com/` | `https://blog.test.com/`          | 跨域     | 子域名不同（`www`/`blog`）     |
| `https://www.test.com/` | `https://www.test.com:8080/`      | 跨域     | 端口号不同（`80`/`8080`）      |

跨域在资源请求中的限制情况：

| 资源类型 | 资源链接不受跨域限制 | 跨域受限               |
| -------- | -------------------- | ---------------------- |
| `js`     | `script` 中的 `src`  | 发起的 `Fetch/XHR`     |
| `css`    | `link` 中的 `href`   | 样式中的 `font` 资源   |
| 图片     | `img` 中的 `src`     | 导入 `canvas` 处理资源 |
| 视频     | `video` 中的 `src`   | 用 `js` 操作媒体资源   |
| 音频     | `audio` 中的 `src`   | 用 `js` 操作媒体资源   |

> 媒体资源操作包括：获取视频的帧数据，或进行某些跨域资源分析等。

这里以发起 `Fetch/XHR` 进行说明，浏览器发送请求同源判定流程：

- 浏览器发出请求
- 服务端做出响应
- 浏览器进行校验，通过校验交付数据，不通过校验引发跨域问题

因此：

1. 无论是否存在跨域，本地发出的请求一定会发送到服务器
2. 无论是否跨域，服务器来一定根据情况做出相应相应
3. 只有浏览器会根据跨域的情况做校验，其他不会，包括内置浏览器的 `postman` 这类工具也不存在跨域

`CORS` 是一套安全机制，用于校验跨域请求，它的基本理念是：

- 只要服务器明确表示允许，则校验通过
- 服务器明确拒绝或没有表示，则校验不通过

从这个原则里可以看出：

- 要用 `CORS` 来解决跨域问题，主要靠服务端参与，仅靠前端在页面上是无法实现的
- 由于需要服务端来参与，因此需要确保拥有服务端操作权限

> 这里不仅仅是指传统的远程服务器，还包括：前端本地服务、`BFF`、代理服务

#### `options` 请求是什么？

`CORS` 将请求分为 2 类：简单请求和预检请求

简单请求必须满足以下条件：

1. **请求方法为**：`GET`、`POST`、`HEAD`
2. **请求头**：头部字段符合 `CORS` 安全规范，见：`W3C` [[查看](https://fetch.spec.whatwg.org/#cors-safelisted-request-header)]
3. 无自定义头部或其他非标准的 `HTTP` 头部字段。

> 以上 3 个条件需要同时满足

`CORS` 安全规范：`HTTP` 请求头信息中，包含以下几种首部且有相应限制

- `header` 头部请求的值不能超过 128 字节
- 只能包含标准的头部字段：`Accept`、`Accept-Language`、`Content-Language`、`Content-Type` 等
- `Content-Type` 首部的值仅限于：`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`。

> 因此 `jwt` 这种需要通过 `authorization` 发送 `token` 的额情况有可能不符合简单请求，下面会说明如何优化

简单请求的请求流程：

- 浏览器会直接发出实际的跨域请求，不需要先发送预检请求（`OPTIONS` 请求）。
- 浏览器发送跨域请求时会自动为请求的头部添加 `Origin`，值为当前页面源。

服务器收到简单请求后，处理流程：

- 服务器根据自身的跨域策略（通常通过设置响应头来体现）来判断是否允许该跨域请求，并返回响应。
- 浏览器拿到响应后会根据 `response` 的头部信息进行校验，校验通过就正常返回相应结果，交付数据。
- 浏览器校验不通过，会根据情况展示给用户相应的错误提示（比如在控制台显示跨域错误等）。

> 服务器在处理过程中的必要操作是提供跨域的头部响应，对于跨域校验通常由浏览器来完成，服务器并非必要操作。

浏览器根据响应的头部判定响应结果：

- 从响应头获取 `Access-Control-Allow-Origin`，值必须包含请求时 `Origin` 请求源
- 或者响应的值也可以是一个 `*`，表示对所有的源都通过

当跨域请求不满足简单请求的定义条件时，就会触发预检请求（`OPTIONS` 请求）：

- 请求方法是 `PUT`、`DELETE` 等非简单请求方法
- 或者 `HTTP` 请求头包含了不在简单请求允许范围内的自定义首部等情况

预检请求的请求流程：

- 首先，浏览器会发送一个预检请求（`OPTIONS` 请求）到服务器。目的是询问服务器是否允许即将发出的实际跨域请求。
- 预检请求中会包含一些信息，比如：
  - 实际请求源（通过 `Origin` 请求头）
  - 实际请求将会使用的方法（通过 `Access-Control-Request-Method` 请求头）
  - 实际请求将会携带的自定义首部（通过 `Access-Control-Request-Headers` 请求头）

服务器收到预检请求后，会根据自身的设置和策略来判断是否允许：

- 如果服务器不允许，就返回一个包含错误信息的响应，浏览器会根据情况展示给用户相应的错误提示。
- 如果允许，服务器会返回一个包含允许信息的响应，浏览器收到这个允许的响应后，才会发出实际的跨域请求。

> 真实请求的流程和简单请求一样

允许跨域的响应通常会设置相应的响应头，比如：

- `Access-Control-Allow-Origin`：告知浏览器允许的请求源
- `Access-Control-Allow-Methods`：告知浏览器允许的请求方法
- `Access-Control-Allow-Headers`：告知浏览器允许的自定义首部
- `Access-Control-Max-Age`：提供一个数字，时间单位秒，告知浏览器指定时间内，不需要重复发送预检请求

**`options` 请求优化**

试想一下如果每一次跨域请求，都需要向服务器发送预检请求，会造成以下问题：

- 频繁向服务器发送预检信息，假定页面有 10 个非简单请求，那么就要额外发送 10 次预检请求
- 请求数据延迟，必须经过预检之后才能发起真实请求

以 `jwt` 场景举例：

- 所有需要鉴权的链接，都需要通过 `header` 设置 `Authorization` 提交 `token`

它存在 2 个问题：

- 不在简单请求的首部范围
- 请求的 `token` 很有可能超过 128 个字符

解决的办法 1：`Access-Control-Max-Age`

- 比如设置 3600 秒，则首次向服务器发送预检请求，拿到响应后 1 小时内不再重复询问

解决办法 2：将 `token` 存入 `cookies`

- 一劳永逸，不再需要因为 `Authorization` 发起预检请求
- `http` 的 `cookie` 下还能确保 `token` 更安全

> 缺点是：`cookies` 有 `4kb` 左右限制，如果 `token` 稍大一点，占用 `1kb` 也不是不可能

</details>
