# 整理前端场景相关的面试题

### 🔴 低代码和微前端有了解吗？

来自：`百安居`

<details>

<summary>答案：</summary>

#### 低代码

低代码是一种快速开发应用程序的方法，有以下几个特性：

1. **特点**：可视化开发、提高产出速度、降低开发门槛
2. **优势**：提高效率、降低人力成本、易于维护
3. **应用场景**：企业内部管理系统、移动应用开发、数据可视化
4. **数据发展**：随着技术的不断进步，低代码开发平台将越来越智能化，能够自动生成更多的代码，进一步提高开发效率。同时，低代码开发也将与人工智能、大数据等技术相结合，为企业提供更强大的解决方案。

由于我本人对 `formily` 比较了解，所以结合 `formily` 的特性在低代码中发挥的用途，我总结的 `formily` 记录：https://github.com/cgfeel/formily

- 提供了开箱即用的开源低代码编辑器
- 采用 `MVVM` 设计模式，精确渲染，将视图模型抽象出来，然后在 DSL 模板层消费
- 提供领域模型，可以多字段联动，主动、被动受控
- 提供点对点的路径系统，能够在低代码中匹配、筛查特定字段
- 细粒度极高的生命周期，从顶层的表单，到底层的字段，从创建到更新，每一个阶段都有对应生命周期
- 协议驱动，提供 `schema`，可以完美通过 `json` 驱动视图
- 分层架构，主要分为 4 大库
  - `@formily/reactive`：数据记录，状态更新
  - `@formily/core`：模型解析、生命周期
  - `@formily/react`：桥接 `react`，使其拥有调用 `formily` 能力
  - `@formily/antd-v5`：`UI` 库之一，作为模型下的组件库，也可以自定义或适配第三方库

#### 微前端

微前端是一种将前端应用拆分为多个独立小型前端应用的架构模式。

**主要特点**

1. **独立开发**：各个微前端应用可以由不同的团队独立开发，使用不同的技术栈，提高开发效率。
2. **独立部署**：每个微前端应用可以独立部署，不影响其他应用，实现快速迭代。
3. **技术栈无关**：允许在一个项目中集成不同技术栈的应用，增加了技术选型的灵活性。

**优势**

1. **提升开发效率**：团队可以专注于特定的微前端应用，减少开发过程中的冲突和协调成本。
2. **增强可维护性**：较小的代码库更容易理解和维护。
3. **灵活升级**：可以逐步升级单个微前端应用，而无需对整个系统进行大规模升级。

**实现方式**

1. **路由分发**：通过路由将不同的 `URL` 分配给不同的微前端应用，如：`qiankun`、`single-spa`。
2. **组合式应用**：将多个微前端应用组合在一个页面中，通过 `iframe` 进行管理，如：`wujie` 降级模式 `degradee`。
3. **微组件化**：将微前端应用封装成 `web-component`，在主应用中动态加载，如：`micro-app`、`wujie` 默认模式。

我总结的微前端记录：https://github.com/cgfeel/zf-micro-app

</details>

### 🔴 谈谈前端性能优化？

来自：`万云科技`

<details>

<summary>以下是前端性能优化的常用策略：</summary>

前端性能优化的核心目标是提高页面加载速度和用户交互体验。

**1. 代码优化**

- **代码分离与按需加载**：使用代码分离（`Code Splitting`）将代码按需加载，以减小首屏的 `JavaScript` 体积。`Webpack` 等打包工具提供了动态导入（`import`）功能来实现按需加载。
- **减少 `JavaScript` 执行时间**：减少过多的 `JavaScript` 运算和 `DOM` 操作，将计算密集型操作移到 `Web Worker` 或服务器端。

**2. 资源优化**

- **压缩和最小化**：通过压缩 `HTML`、`CSS`、`JavaScript` 来减少资源大小。常用工具包括 `Terser`（`JS`）、`CSSNano`（`CSS`）等。
- **图片优化**：优化图片格式（如 `WebP`）、使用图片懒加载、并适配不同分辨率的设备。
- **使用字体优化**：尽量使用系统字体，或确保自定义字体在加载前不阻塞页面渲染。

**3. 网络优化**

- **使用 `HTTP/2` 或 `HTTP/3`**：`HTTP/2` 支持多路复用和更高效的资源加载，使浏览器能够同时加载多个资源而无需排队。
- **缓存与 `Service Worker`**：利用缓存策略（如 `HTTP` 缓存、`Service Worker` 缓存）来减少重复加载静态资源，提升返回用户的加载速度。
- **内容分发网络（`CDN`）**：通过 `CDN` 加速全球用户的资源加载，减少资源的传输时间。

**4. 页面渲染优化**

- **减少重绘与重排**：避免频繁修改 `DOM`，以减少布局和渲染的消耗。可以通过批量操作 `DOM`，或使用虚拟 `DOM` 技术来降低成本。
- **`CSS` 优化**：将关键 `CSS`（`Critical CSS`）放在页面顶部，其他的 `CSS` 文件可以异步加载，以加快页面的首屏渲染。

**5. 提高交互性能**

- **合理使用事件委托**：对于频繁的 `DOM` 事件（如点击、鼠标移动等），使用事件委托来提升性能，减少事件绑定数量。
- **懒加载非必要资源**：如图像、视频和数据，可以在用户接近相关区域时进行加载，避免一次性加载所有资源的负担。
- **减少首屏加载的 `JavaScript`**：通过 `Tree Shaking` 删除无用代码，并延迟加载非关键代码，以减少加载时间。

**6. 提高体验的优化**

- **优先显示关键内容**：确保首屏重要内容优先加载，尽量缩短用户首次看到页面的时间。
- **合理使用骨架屏与加载动画**：在加载较慢的情况下，使用骨架屏或加载动画来增强用户体验，避免白屏时间过长。

这些策略可以综合运用，具体选择需根据项目实际需求和用户设备、网络情况来决定。

</details>

### 🔴 说下 `XSS` 攻击，以及前端如何预防？

来自：`gate.io`

<details>

<summary>答案：</summary>

#### `XSS`（跨站脚本攻击）概述

`XSS` 攻击是一种常见的网络安全漏洞，攻击者通过在目标网站中注入恶意脚本（通常是 `JavaScript`），来获取用户的敏感信息（如登录凭证、个人信息等）或者执行其他恶意操作。这些恶意脚本会在用户的浏览器中执行，而用户往往是在正常访问目标网站的过程中被攻击。

**攻击类型有 3 个**

- **存储型 `XSS`**：攻击者将恶意脚本存储在目标服务器上，例如在网站的评论区、留言板等可以存储用户输入内容的地方。当其他用户访问包含恶意脚本的页面时，浏览器会加载并执行这些脚本。例如，攻击者在一个论坛的评论中插入一段恶意 `JavaScript` 代码，当其他用户查看该评论时，代码就会执行，可能会窃取用户的登录信息。
- **反射型 `XSS`**：攻击者构造一个带有恶意脚本的 `URL`，诱使用户点击。当用户访问这个 `URL` 时，服务器会将恶意脚本反射回用户的浏览器并执行。比如，攻击者通过电子邮件等方式发送一个包含恶意脚本的链接，用户点击链接后，服务器会将脚本返回给浏览器执行。
- **`DOM` - `based XSS`**：这种类型的 `XSS` 是基于文档对象模型（`DOM`）的。攻击者利用网站前端 `JavaScript` 代码中的漏洞，通过修改 `DOM` 树来执行恶意脚本。例如，网站的某个 `JavaScript` 函数在处理用户输入时，没有正确地验证或转义，使得攻击者可以通过操作 `DOM` 来注入并执行恶意脚本。

#### 如何防止 `XSS` 攻击

从以下 4 个方面避免 `XSS` 攻击

**1. 输入验证和过滤：**

- **转义 `HTML` 特殊字符：**：将用户输入中的 `&`、`<`、`>`、`"`、`'` 等特殊字符替换为相应的 `HTML` 实体。
- **输入验证和清理**：对于用户输入的任何内容，如表单输入、`URL` 参数等，都应该进行严格的验证。验证内容包括数据类型、长度、格式等。

转义 `HTML` 特殊字符示例：

```js
function _getProcessedContent(content) {
  return content
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;")
    .replace(/`([\S\s]+?)`/g, "<code>$1</code>");
}
```

这样，即使攻击者输入了恶意脚本，在浏览器中也会被当作普通文本显示，而不会被执行。

**2. 输出编码：**

- **`HTML` 编码**：在将数据输出到 `HTML` 页面时，如在显示用户评论、文章内容等情况下，要对数据进行 `HTML` 编码。
- **`JavaScript` 编码**：如果数据是要在 `JavaScript` 代码中使用，一定要进行严格的编码和验证。例如，对于要在 `eval` 函数中使用的数据，会直接执行传入的字符串作为 `JavaScript` 代码。

**3. 安全的 `DOM` 操作：**

- **避免使用危险的 `DOM API`**：如 `document.write` 容易导致 `DOM` - `based XSS` 攻击。
- **正确处理 `DOM` 更新**：在更新 `DOM` 时，要注意使用的数据来源。例如，在使用 `innerHTML` 时，要对插入的内容进行 `HTML` 编码，防止恶意脚本注入。对于通过 `addEventListener` 等方式添加的事件处理函数，也要注意防止恶意脚本通过事件参数等途径注入。

**4. 借助安全策略和现有的库：**

- **使用 `CSP`（内容安全策略）**：通过 `HTTP` 头部设置内容安全策略，限制可以执行的脚本类型及来源。
- **使用库和框架的内置安全功能**：利用 `React`、`Vue` 等现代框架中的内置功能自动处理和防范 `XSS` 攻击。

#### `React` 怎么防止 `XSS` 的

**`React` 对 `XSS` 的自动防御机制：**

- **自动转义**：`React` 在渲染过程中有自动转义机制。将数据渲染到 `DOM` 中（例如，通过 `{}` 语法将一个变量渲染到 `JSX` 组件内部），`React` 会自动对数据中的特殊字符进行转义。
- **使用虚拟 `DOM`（`Virtual DOM`）**：`React` 使用虚拟 `DOM` 来更新真实 `DOM`。在虚拟 `DOM` 的比较和更新过程中，`React` 会对要更新的数据进行安全检查。它不会盲目地将数据直接更新到真实 `DOM` 中，而是先在虚拟 `DOM` 层面进行处理。这种机制减少了直接操作真实 `DOM` 可能带来的安全风险，因为恶意脚本很难直接绕过虚拟 `DOM` 的检查而插入到真实 `DOM` 中执行。

**开发者的最佳实践：**

- **避免使用 `dangerouslySetInnerHTML`**：这是一个容易引入 `XSS` 风险的属性。只有在绝对必要的情况下才使用它，并且在使用时，要确保传递给 `__html` 属性的值是经过严格安全处理的。
- **验证和过滤用户输入**：与其他开发场景一样，在 `React` 中也要对用户输入进行验证和过滤。在组件的 `state` 或者 `props` 接收用户输入数据的地方，要进行严格的验证。
- **安全的组件通信和数据传递**：当父组件将数据传递给子组件作为 `props` 时，要保证数据是经过验证和安全处理的。同样，在使用 `context` 等高级特性进行数据共享时，也要注意数据的来源和安全性，防止恶意数据在组件之间传播并导致 `XSS` 攻击。

</details>
