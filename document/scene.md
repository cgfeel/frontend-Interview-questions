# 整理前端场景相关的面试题

### 🔴 低代码和微前端有了解吗？

来自：`百安居`

<details>

<summary>答案：</summary>

#### 低代码

低代码是一种快速开发应用程序的方法，有以下几个特性：

1. **特点**：可视化开发、提高产出速度、降低开发门槛
2. **优势**：提高效率、降低人力成本、易于维护
3. **应用场景**：企业内部管理系统、移动应用开发、数据可视化
4. **数据发展**：随着技术的不断进步，低代码开发平台将越来越智能化，能够自动生成更多的代码，进一步提高开发效率。同时，低代码开发也将与人工智能、大数据等技术相结合，为企业提供更强大的解决方案。

由于我本人对 `formily` 比较了解，所以结合 `formily` 的特性在低代码中发挥的用途，我总结的 `formily` 记录：https://github.com/cgfeel/formily

- 提供了开箱即用的开源低代码编辑器
- 采用 `MVVM` 设计模式，精确渲染，将视图模型抽象出来，然后在 DSL 模板层消费
- 提供领域模型，可以多字段联动，主动、被动受控
- 提供点对点的路径系统，能够在低代码中匹配、筛查特定字段
- 细粒度极高的生命周期，从顶层的表单，到底层的字段，从创建到更新，每一个阶段都有对应生命周期
- 协议驱动，提供 `schema`，可以完美通过 `json` 驱动视图
- 分层架构，主要分为 4 大库
  - `@formily/reactive`：数据记录，状态更新
  - `@formily/core`：模型解析、生命周期
  - `@formily/react`：桥接 `react`，使其拥有调用 `formily` 能力
  - `@formily/antd-v5`：`UI` 库之一，作为模型下的组件库，也可以自定义或适配第三方库

#### 微前端

微前端是一种将前端应用拆分为多个独立小型前端应用的架构模式。

**主要特点**

1. **独立开发**：各个微前端应用可以由不同的团队独立开发，使用不同的技术栈，提高开发效率。
2. **独立部署**：每个微前端应用可以独立部署，不影响其他应用，实现快速迭代。
3. **技术栈无关**：允许在一个项目中集成不同技术栈的应用，增加了技术选型的灵活性。

**优势**

1. **提升开发效率**：团队可以专注于特定的微前端应用，减少开发过程中的冲突和协调成本。
2. **增强可维护性**：较小的代码库更容易理解和维护。
3. **灵活升级**：可以逐步升级单个微前端应用，而无需对整个系统进行大规模升级。

**实现方式**

1. **路由分发**：通过路由将不同的 `URL` 分配给不同的微前端应用，如：`qiankun`、`single-spa`。
2. **组合式应用**：将多个微前端应用组合在一个页面中，通过 `iframe` 进行管理，如：`wujie` 降级模式 `degradee`。
3. **微组件化**：将微前端应用封装成 `web-component`，在主应用中动态加载，如：`micro-app`、`wujie` 默认模式。

我总结的微前端记录：https://github.com/cgfeel/zf-micro-app

</details>

### 🔴 谈谈前端性能优化？

来自：`万云科技`

<details>

<summary>以下是前端性能优化的常用策略：</summary>

前端性能优化的核心目标是提高页面加载速度和用户交互体验。

**1. 代码优化**

- **代码分离与按需加载**：使用代码分离（`Code Splitting`）将代码按需加载，以减小首屏的 `JavaScript` 体积。`Webpack` 等打包工具提供了动态导入（`import`）功能来实现按需加载。
- **减少 `JavaScript` 执行时间**：减少过多的 `JavaScript` 运算和 `DOM` 操作，将计算密集型操作移到 `Web Worker` 或服务器端。

**2. 资源优化**

- **压缩和最小化**：通过压缩 `HTML`、`CSS`、`JavaScript` 来减少资源大小。常用工具包括 `Terser`（`JS`）、`CSSNano`（`CSS`）等。
- **图片优化**：优化图片格式（如 `WebP`）、使用图片懒加载、并适配不同分辨率的设备。
- **使用字体优化**：尽量使用系统字体，或确保自定义字体在加载前不阻塞页面渲染。

**3. 网络优化**

- **使用 `HTTP/2` 或 `HTTP/3`**：`HTTP/2` 支持多路复用和更高效的资源加载，使浏览器能够同时加载多个资源而无需排队。
- **缓存与 `Service Worker`**：利用缓存策略（如 `HTTP` 缓存、`Service Worker` 缓存）来减少重复加载静态资源，提升返回用户的加载速度。
- **内容分发网络（`CDN`）**：通过 `CDN` 加速全球用户的资源加载，减少资源的传输时间。

**4. 页面渲染优化**

- **减少重绘与重排**：避免频繁修改 `DOM`，以减少布局和渲染的消耗。可以通过批量操作 `DOM`，或使用虚拟 `DOM` 技术来降低成本。
- **`CSS` 优化**：将关键 `CSS`（`Critical CSS`）放在页面顶部，其他的 `CSS` 文件可以异步加载，以加快页面的首屏渲染。

**5. 提高交互性能**

- **合理使用事件委托**：对于频繁的 `DOM` 事件（如点击、鼠标移动等），使用事件委托来提升性能，减少事件绑定数量。
- **懒加载非必要资源**：如图像、视频和数据，可以在用户接近相关区域时进行加载，避免一次性加载所有资源的负担。
- **减少首屏加载的 `JavaScript`**：通过 `Tree Shaking` 删除无用代码，并延迟加载非关键代码，以减少加载时间。

**6. 提高体验的优化**

- **优先显示关键内容**：确保首屏重要内容优先加载，尽量缩短用户首次看到页面的时间。
- **合理使用骨架屏与加载动画**：在加载较慢的情况下，使用骨架屏或加载动画来增强用户体验，避免白屏时间过长。

这些策略可以综合运用，具体选择需根据项目实际需求和用户设备、网络情况来决定。

</details>

### 🔴 说下 `XSS` 攻击，以及前端如何预防？

来自：`gate.io`

<details>

<summary>答案：</summary>

#### `XSS`（跨站脚本攻击）概述

`XSS` 攻击是一种常见的网络安全漏洞，攻击者通过在目标网站中注入恶意脚本（通常是 `JavaScript`），来获取用户的敏感信息（如登录凭证、个人信息等）或者执行其他恶意操作。这些恶意脚本会在用户的浏览器中执行，而用户往往是在正常访问目标网站的过程中被攻击。

**攻击类型有 3 个**

- **存储型 `XSS`**：攻击者将恶意脚本存储在目标服务器上，例如在网站的评论区、留言板等可以存储用户输入内容的地方。当其他用户访问包含恶意脚本的页面时，浏览器会加载并执行这些脚本。例如，攻击者在一个论坛的评论中插入一段恶意 `JavaScript` 代码，当其他用户查看该评论时，代码就会执行，可能会窃取用户的登录信息。
- **反射型 `XSS`**：攻击者构造一个带有恶意脚本的 `URL`，诱使用户点击。当用户访问这个 `URL` 时，服务器会将恶意脚本反射回用户的浏览器并执行。比如，攻击者通过电子邮件等方式发送一个包含恶意脚本的链接，用户点击链接后，服务器会将脚本返回给浏览器执行。
- **`DOM` - `based XSS`**：这种类型的 `XSS` 是基于文档对象模型（`DOM`）的。攻击者利用网站前端 `JavaScript` 代码中的漏洞，通过修改 `DOM` 树来执行恶意脚本。例如，网站的某个 `JavaScript` 函数在处理用户输入时，没有正确地验证或转义，使得攻击者可以通过操作 `DOM` 来注入并执行恶意脚本。

#### 如何防止 `XSS` 攻击

从以下 4 个方面避免 `XSS` 攻击

**1. 输入验证和过滤：**

- **转义 `HTML` 特殊字符：**：将用户输入中的 `&`、`<`、`>`、`"`、`'` 等特殊字符替换为相应的 `HTML` 实体。
- **输入验证和清理**：对于用户输入的任何内容，如表单输入、`URL` 参数等，都应该进行严格的验证。验证内容包括数据类型、长度、格式等。

转义 `HTML` 特殊字符示例：

```js
function _getProcessedContent(content) {
  return content
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;")
    .replace(/`([\S\s]+?)`/g, "<code>$1</code>");
}
```

这样，即使攻击者输入了恶意脚本，在浏览器中也会被当作普通文本显示，而不会被执行。

**2. 输出编码：**

- **`HTML` 编码**：在将数据输出到 `HTML` 页面时，如在显示用户评论、文章内容等情况下，要对数据进行 `HTML` 编码。
- **`JavaScript` 编码**：如果数据是要在 `JavaScript` 代码中使用，一定要进行严格的编码和验证。例如，对于要在 `eval` 函数中使用的数据，会直接执行传入的字符串作为 `JavaScript` 代码。

**3. 安全的 `DOM` 操作：**

- **避免使用危险的 `DOM API`**：如 `document.write` 容易导致 `DOM` - `based XSS` 攻击。
- **正确处理 `DOM` 更新**：在更新 `DOM` 时，要注意使用的数据来源。例如，在使用 `innerHTML` 时，要对插入的内容进行 `HTML` 编码，防止恶意脚本注入。对于通过 `addEventListener` 等方式添加的事件处理函数，也要注意防止恶意脚本通过事件参数等途径注入。

**4. 借助安全策略和现有的库：**

- **使用 `CSP`（内容安全策略）**：通过 `HTTP` 头部设置内容安全策略，限制可以执行的脚本类型及来源。
- **使用库和框架的内置安全功能**：利用 `React`、`Vue` 等现代框架中的内置功能自动处理和防范 `XSS` 攻击。

#### `React` 怎么防止 `XSS` 的

**`React` 对 `XSS` 的自动防御机制：**

- **自动转义**：`React` 在渲染过程中有自动转义机制。将数据渲染到 `DOM` 中（例如，通过 `{}` 语法将一个变量渲染到 `JSX` 组件内部），`React` 会自动对数据中的特殊字符进行转义。
- **使用虚拟 `DOM`（`Virtual DOM`）**：`React` 使用虚拟 `DOM` 来更新真实 `DOM`。在虚拟 `DOM` 的比较和更新过程中，`React` 会对要更新的数据进行安全检查。它不会盲目地将数据直接更新到真实 `DOM` 中，而是先在虚拟 `DOM` 层面进行处理。这种机制减少了直接操作真实 `DOM` 可能带来的安全风险，因为恶意脚本很难直接绕过虚拟 `DOM` 的检查而插入到真实 `DOM` 中执行。

**开发者的最佳实践：**

- **避免使用 `dangerouslySetInnerHTML`**：这是一个容易引入 `XSS` 风险的属性。只有在绝对必要的情况下才使用它，并且在使用时，要确保传递给 `__html` 属性的值是经过严格安全处理的。
- **验证和过滤用户输入**：与其他开发场景一样，在 `React` 中也要对用户输入进行验证和过滤。在组件的 `state` 或者 `props` 接收用户输入数据的地方，要进行严格的验证。
- **安全的组件通信和数据传递**：当父组件将数据传递给子组件作为 `props` 时，要保证数据是经过验证和安全处理的。同样，在使用 `context` 等高级特性进行数据共享时，也要注意数据的来源和安全性，防止恶意数据在组件之间传播并导致 `XSS` 攻击。

</details>

### 🔴 如何优化前端 `FCP`？

来自：`gate.io`

<details>

<summary>以下是 First Contentful Paint，首次内容绘制优化方法：</summary>

#### 一、优化资源加载

**1. 代码拆分（`Code Splitting`）**

将大型的 `JavaScript` 代码库拆分成多个较小的模块，按需加载。这样浏览器就不用一次性下载和解析大量代码，而是根据用户的交互或者页面的初始呈现需求逐步获取所需代码，能有效减少首次页面加载时的资源量，加快 `FCP` 的时间。

示例：

在使用 `webpack` 等构建工具时，可以利用其动态导入（`import()`）功能实现代码拆分。比如一个电商网站，有商品列表展示模块、购物车模块、用户登录模块等，可以把这些模块对应的代码分别拆分出来，当用户访问商品列表页面时，先只加载商品列表展示相关的代码，等用户点击进入购物车页面时再加载购物车模块代码。

**2. 优化 `CSS` 和 `JavaScript` 加载顺序**

通常将关键的 `CSS` 样式表放在页面头部加载，这样浏览器可以尽早开始渲染页面样式，避免出现页面无样式的 “白屏” 阶段，进而加快首次内容绘制。对于 `JavaScript`，除非是页面初始化必须依赖的脚本，否则尽量放在页面底部加载，防止 `JavaScript` 解析阻塞页面渲染进程，影响 `FCP`。

在 HTML 文件中，像下面这样安排资源加载顺序：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="stylesheet" href="styles.css" />
    <!-- 关键 CSS 优先加载 -->
  </head>
  <body>
    <!-- 页面内容主体 -->
    <script src="main.js"></script>
    <!-- 非关键 JavaScript 放底部 -->
  </body>
</html>
```

**3. 懒加载（`Lazy Loading`）**

针对图片、视频等多媒体资源以及页面下方的一些非关键内容采用懒加载机制。即这些资源在页面初始加载时不会被下载，只有当它们进入浏览器的可视区域时才会按需加载，从而减少首次页面加载时的资源请求数量，提升 `FCP` 速度。

对于图片，可以使用 `HTML5` 的 `data-*` 属性结合 `JavaScript` 来实现懒加载。例如：

```html
<img data-src="large-image.jpg" alt="示例图片" class="lazyload" />
```

然后通过 `JavaScript` 监听页面滚动等事件，当图片元素进入可视区域时，将 `data-src` 属性的值赋给 `src` 属性，触发图片的加载：

```js
// 以下代码只做演示，没有考虑节流，生成环境请勿直接使用
const lazyImages = document.querySelectorAll(".lazyload");
const lazyLoad = function () {
  lazyImages.forEach((image) => {
    if (
      image.getBoundingClientRect().top < window.innerHeight &&
      image.getBoundingClientRect().bottom > 0
    ) {
      image.src = image.dataset.src;
      image.classList.remove("lazyload");
    }
  });
};
window.addEventListener("scroll", lazyLoad);
window.addEventListener("load", lazyLoad);
```

#### 二、优化网络请求

**1. 压缩资源**

对 `CSS`、`JavaScript`、`HTML` 等文件进行压缩，去除多余的空格、注释等冗余信息，减小文件体积，加快网络传输速度，使浏览器能更快获取资源并进行页面渲染，有助于优化 `FCP`。

在构建项目时，使用工具如 `UglifyJS` 对 `JavaScript` 文件进行压缩，使用 `cssnano` 对 `CSS` 文件进行压缩，同时 `HTML` 文件也可以通过相关构建插件来压缩，例如在基于 `Node.js` 的项目中，通过配置 `html-webpack-plugin` 可以在打包时自动压缩 `HTML` 文件。

**2. 使用 `CDN`（`Content Delivery Network`）**

将静态资源（如图片、脚本、样式表等）分发到多个地理位置的服务器节点上，当用户访问页面时，浏览器可以从距离用户最近的服务器获取资源，大大缩短了资源的传输时间，能有效加快页面首次内容绘制的速度。

对于一些常用的前端库，像 `jQuery`，可以使用其官方提供的 `CDN` 链接来加载：

```js
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
```

同时，企业自己的网站也可以部署 CDN 来存放自己的静态资源，比如图片、样式文件等。

**3. 减少 `HTTP` 请求数量**

每一个 `HTTP` 请求都会有一定的开销，包括建立连接、发送请求头、等待响应等时间成本。通过合并 `CSS` 和 `JavaScript` 文件、使用雪碧图（`CSS Sprite`）等方式减少请求次数，从而加快页面加载速度，改善 `FCP`。

如果有多个小的 `CSS` 文件，可以使用构建工具将它们合并成一个大的 `CSS` 文件；对于页面中用到的多个小图标，可以通过工具将它们整合到一张雪碧图中，然后利用 `CSS` 的 `background-position` 属性来定位显示不同的图标，减少图标对应的单独 `HTTP` 请求。

#### 三、优化页面结构与渲染

**1. 精简 `HTML` 结构**

保持 `HTML` 页面结构简洁，去除不必要的标签嵌套和多余的元素，让浏览器能更快地解析和渲染页面内容，有助于缩短首次内容绘制时间。

避免像下面这样过度嵌套的 HTML 结构：

```html
<div>
  <div>
    <p><span>这是一段文本</span></p>
  </div>
</div>
```

可以简化为：

```html
<p>这是一段文本</p>
```

**2. 避免重排（`Reflow`）和重绘（`Repaint`）**

当页面元素的布局（尺寸、位置等）或样式（颜色、背景等）发生改变时，浏览器会进行重新布局（重排）和重新绘制（重绘）操作，这些操作会消耗一定的性能，影响 `FCP`。尽量减少不必要的元素样式和布局的频繁变动，通过改变类名应用预定义的样式变化、使用 `transform` 和 `opacity` 等属性来实现动画效果等方式来降低重排和重绘的频率。

如果要实现一个元素的隐藏动画，不要使用 `display: none`（会引起重排和重绘），而是使用 `opacity: 0` 结合 `visibility: hidden` 以及 `transition` 属性来实现平滑的隐藏效果，减少对页面渲染性能的影响。

**3. 使用浏览器缓存**

合理设置浏览器缓存策略，让浏览器对已经访问过的静态资源（如 `CSS`、`JavaScript`、图片等）进行缓存，下次访问同一页面或者相关页面时，就可以直接从本地缓存中获取资源，无需再次发起网络请求，从而加快页面加载速度，优化 `FCP`。

在服务器端，可以通过设置 `HTTP` 响应头来控制缓存，比如：

```bash
Cache-Control: max-age=3600, public
```

这表示资源可以被客户端（浏览器）缓存，有效期为 1 小时（3600 秒），并且可以被多个用户共享缓存（`public` 表示公共缓存）。

通过综合运用上述这些优化方法，可以有效提升前端 `FCP` 性能，让用户能更快地看到页面的首次内容呈现，改善用户体验。

</details>
